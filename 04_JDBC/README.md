# Версии
- jdbc_app_1 - реализованно подключение через JDBC API к БД(PostgreSQL), id у всех пользователей на данный момент 1
- jdbc_app_2 - JDBC API заменено на JdbcTemplate;
- jdbc_app_3 - добавлен файл properties
- jdbc_app_4(тестовая версия) - Batch Update
    - Batch Update - снижаем нагрузку на БД,  распараллеливание запросов и упаковка как один пакет
- jdbc_app_5 - добавлено автоматическое генерирование идентификатора
- jdbc_app_6 - добавлена валидация Spring (@Patter), добавлено поле address
# JDBC
<img width="500" alt="Screen Shot 2022-05-18 at 7 39 36 PM" src="https://user-images.githubusercontent.com/92088165/169096374-aec3d858-2051-493f-af29-7857940cd7ef.png">

```
create table Person (
    id int,
    name varchar,
    age int,
    email varchar
);
insert into person values (1, 'Tom', 18, 'tom@mail.com');
insert into person values (1, 'Bob', 21, 'bob@mail.com');
insert into person values (1, 'Mike', 42, 'mke@mail.com');
insert into person values (1, 'Katy', 14, 'katy@mail.com');
```

```
create sequence first_sequence //обьект выдает целые числа по порядку
select nextval('first_sequence')
```

```
create table Person(
    id SERIAL, //псевдотип (создает sequence (название таблицы_id_sequence))
    name varchar,
    age int,
    email varchar
)
insert into person(name, age, email) values('Tom', 18, 'tom@mail.com');
insert into person(name, age, email) values('Bob', 21, 'bob@mail.com');
insert into person(name, age, email) values('Mike', 42, 'mke@mail.com');
insert into person(name, age, email) values('Katy', 14, 'katy@mail.com');
```
После 10 версии
```
create table Person(
    id int GENERATED BY DEFAULT AS IDENTITY,
    name varchar,
    age int,
    email varchar
)
```
Ограничения
1. NOT NULL
2. UNIQUE
3. PRIMARY KEY (NOT NULL + UNIQUE) (идентификатор строки)
4. FOREIGN KEY внешний ключ (связующий элемент)
5. CHECK - ограничения на значения (age int CHECK (age > 0))

```
create table Person(
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name varchar NOT NULL,
    age int check ( age > 0 ),
    email varchar UNIQUE NOT NULL
)
```
# DB

One to Many (связь происходит через FK)

<img width="500" alt="Screen Shot 2022-05-19 at 11 58 47 AM" src="https://user-images.githubusercontent.com/92088165/169255312-844ea364-be1c-485d-afc4-d446351c57b1.png">

One to One (дочерняя таблица одновременно PK и FK)

<img width="500" alt="Screen Shot 2022-05-19 at 12 02 55 PM" src="https://user-images.githubusercontent.com/92088165/169256150-8b1fb79f-72d3-476e-9ce7-da27aab0654d.png">

Many to Many (через Join Table (Составной PK - (Fk, FK))

<img width="500" alt="Screen Shot 2022-05-19 at 12 08 42 PM" src="https://user-images.githubusercontent.com/92088165/169257476-f2535d0e-534b-485f-ac93-bc40290e2c0b.png">

# Слияние
- Inner Join ```SELECT * FROM Person JOIN Order ON Person.user_id = Order.user_id;``` (если пара не найдена строка не отоброзится)
- Outer Join. 
- - Left Join ```SELECT * FROM Person LEFT JOIN Order ON Person.user_id = Order.user_id;``` (если пара не найдена, отобразит (null))
- - Right Join ```SELECT * FROM Person RIGHT JOIN Order ON Person.user_id = Order.user_id;``` (сопостовляет с левой таблицей (основа правая))
- Cross Jion ```SELECT * FROM Person CROSS JOIN Order;``` (все возможные сопоставления двух таблиц)

```
create table Movie (
    movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    director_id int NOT NULL REFERENCES Director(director_id), //связь один к многим
    name varchar NOT NULL,
    year_of_production int
)
```
```
create table Passport (
    citizen_id int PRIMARY KEY REFERENCES citizen(citizen_id), //один к одному
    pasport_number int
)
```
```
create table Actor_Movie( //многие к многим
    actor_id int REFERENCES Actor(actor_id),
    movie_id int REFERENCES Movie(movie_id)
    PRIMARY KEY (actor_id, movie_id) /составной ключ
)
```

table1 JOIN table1_table2 JOIN table2
# индексы в PostgreSQ
```
CREATE INDEX ON Transaction(amount) USING ???
```
- PRIMARY KEY
- B-Tree Index
- Hash Index
- Gin & Gist Index
- BRIN Index

# Каскадирование
При наличии связей DELETE не сработает, 
```
user_id int REFERENCES Person(user_id) ON DELETE ???
```
- CASCADE - удаляет строки в зависимой таблице при удалении связанных строк в главной таблице
- SET NULL - вставляет значение внешнего ключа равным NULL при удалении строк в главной таблице
- RESTRICT - поведение по умочанию (т.е ошибка)
